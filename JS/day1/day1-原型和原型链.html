<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
<script>
    /*
    * 1. 原型
    *       * 解决问题
    *           当你需要给实例对象添加方法  直接书写在构造函数体内
    *           这个行为并不好  原型就是为了解决这个问题
    *       * 不好的原因
    *           当我把方法写在函数体内  每次创建实例对象 就会创建一个函数数据类型
    *           多个函数方法  一模一样 但是占据了多份存储空间
    *       * 原型
    *           概念： 每一个构造函数天生自带一个prototype属性 ，是一个对象数据类型
    *           概念： 每一个对象天生自带一个属性 __proto__ ,指向所属构造函数的prototype
    *           概念： 当你访问对象成员时候，首先在自己身上查找 如果没有 去__proto__上查找
    *       * 原型如何解决问题
    *           把需要添加给实例的方法 放在构造函数的原型上 就可以有实例进行访问使用
    *       * 原型：构造函数天生自带一个prototype 它的作用是，由构造函数添加方法，专门给实例对象使用
    * 2. 原型链
    *       * 问题一； 实例对象身上的__proto__指向谁？
    *                   指向所属构造函数的prototype
    *       * 问题二： Person.prototype 的 __proto__ 指向谁？
    *                   Person.prototype所属的构造函数是Object这个内置构造函数  在js内 所有的Object数据类型都是属于Object这个内置构造函数  因为Person构造函数是属于Object这个构造函数的  所以Person.prototype指向Object.prototype
    *       * 问题三： Person的 __proto__ 指向谁？
    *                   Person是一个函数，函数本身也是一个对象，就会有__proto__    在js中，所有的函数都是属于内置构造函数Function的实例， 所以，Person.__proto__指向function.prototype
    *       * 问题四： Object.prototype 的 __proto__ 指向谁？
    *                   注意！！！！
    *                   Object.prototype在js内叫顶级原型，不在有__proto__
    *       * 问题五： Object 的__proto__指向谁？
    *                   因为Object是一个函数，同时也是一个对象，在js内，所有的函数都属于内置构造函数Function的实例，所以Object.__proto__指向Function.prototype
    *       * 问题六： Function.prototype 的 __proto__ 指向谁？
    *                   Function.prototype是一个原型对象，是一个对象，在js中 所有的对象都属于Object这个内置构造函数，所以  Function.prototype.__proto__指向Object.prototype
    *       * 问题七： Function 的__proto__指向谁？
    *                   Function也是一个内置构造函数，也是一个函数，在js中，所有函数都是属于内置构造函数Function的实例，Function自己是自己的构造函数，自己是自己的实例对象，Function所属的构造函数是Function
    *   原型链就是用__proto__串连起来的对象链状结构
    *   注意！！！使用__proto__串联
    *   每一个对象数据类型都有一个属于自己的原型链，作用就是为了访问对象成员
    *   对象访问机制：
    *       当你需要访问对象的成员的时候，首先在自己身上查找，如果有直接用，如果没有，会自动去__proto__上查找，如果还没有，就再去__proto__上查找，直到Object.prototype都没有，那么返回undefined
    * */
    function Person(name, age) {
        // 向实例对象内添加属性
        this.name = name
        this.age = age
        // 向实例对象内添加方法
        // this.sayHi = function () {
        //     console.log('hello')
        // }
    }

    Person.prototype.sayHi = function () {
        console.log('hello world');
    } 
    var p1 = new Person('mzh', 19)
    var p2 = new Person('zsq', 20)
    console.log(p1);
    console.log(p2);
    console.log(p1.sayHi);
    p1.sayHi()
    p2.sayHi()
    console.log(p2.sayHi);
    console.log(p1.sayHi === p2.sayHi);
    console.log(Person.prototype);

</script>
</body>
</html>